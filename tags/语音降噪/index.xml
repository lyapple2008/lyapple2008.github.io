<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>语音降噪 on BeYoung</title>
    <link>https://lyapple2008.github.io/tags/%E8%AF%AD%E9%9F%B3%E9%99%8D%E5%99%AA/</link>
    <description>Recent content in 语音降噪 on BeYoung</description>
    <image>
      <title>BeYoung</title>
      <url>https://lyapple2008.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://lyapple2008.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.149.0</generator>
    <language>zh</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 ·</copyright>
    <lastBuildDate>Mon, 11 Aug 2025 22:27:28 +0800</lastBuildDate>
    <atom:link href="https://lyapple2008.github.io/tags/%E8%AF%AD%E9%9F%B3%E9%99%8D%E5%99%AA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>语音增强算法评估指南</title>
      <link>https://lyapple2008.github.io/posts/2025-08-11-%E9%9F%B3%E9%A2%91%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/</link>
      <pubDate>Mon, 11 Aug 2025 22:27:28 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/2025-08-11-%E9%9F%B3%E9%A2%91%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/</guid>
      <description>&lt;h1 id=&#34;语音增强算法评估指南&#34;&gt;语音增强算法评估指南&lt;/h1&gt;
&lt;p&gt;如今语音增强算法已成为智能设备、视频会议和助听器等应用的核心，它能从嘈杂环境中“拯救”清晰的语音信号，但如何判断一个算法的好坏？这就是评估的意义所在。今天，我们来聊聊语音增强算法的评估体系，通过一个国际挑战赛作为切入点，带你一步步了解关键指标和计算方法。无论你是初学者还是从业者，这篇文章都能帮你理清思路。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="语音增强算法评估指南">语音增强算法评估指南</h1>
<p>如今语音增强算法已成为智能设备、视频会议和助听器等应用的核心，它能从嘈杂环境中“拯救”清晰的语音信号，但如何判断一个算法的好坏？这就是评估的意义所在。今天，我们来聊聊语音增强算法的评估体系，通过一个国际挑战赛作为切入点，带你一步步了解关键指标和计算方法。无论你是初学者还是从业者，这篇文章都能帮你理清思路。</p>
<h2 id="前言为什么需要评估语音增强算法">前言：为什么需要评估语音增强算法？</h2>
<p>想象一下，你开发了一个语音增强模型，自认为它能完美去除背景噪音。但在实际应用中，用户反馈“声音听起来怪怪的”或“某些噪音下完全失效”。这就是为什么评估至关重要：它提供了一个客观、量化的标准，帮助开发者识别算法的优缺点、优化性能，并与其他方法进行公平比较。</p>
<p>评估的作用主要体现在三个方面：</p>
<ul>
<li><strong>指导开发</strong>：通过指标反馈，迭代模型设计，避免主观偏见。</li>
<li><strong>基准比较</strong>：在竞赛或论文中，用统一标准衡量不同算法的进步。</li>
<li><strong>实际部署</strong>：确保算法在真实场景（如移动端或低信噪比环境）下的鲁棒性和通用性。</li>
</ul>
<p>没有评估，算法开发就像盲人摸象；有了评估，它就成了科学工程。接下来，我们以NeurIPS 2024竞赛轨道下的URGENT 2024挑战为例，深入探讨评估体系。这个挑战聚焦于构建通用语音增强模型，强调在不同噪声、采样率和麦克风配置下的表现。</p>
<h2 id="urgent-2024挑战评估体系的典范">URGENT 2024挑战：评估体系的典范</h2>
<p><a href="https://urgent-challenge.github.io/urgent2024/">URGENT 2024（Universality, Robustness, and Generalizability for EnhancemeNT）</a>挑战旨在解决传统语音增强研究的痛点：许多算法只针对特定条件优化，缺乏跨场景泛化能力。挑战要求参赛者使用统一的公共数据集训练单一模型，处理各种失真（如噪声、混响），并支持不同输入格式（如单/多通道、不同采样率）。</p>
<p>这个挑战的亮点在于其全面评估框架，包括非侵入式（无参考信号）和侵入式（需参考信号）指标，以及下游任务相关指标（如词错误率WER）。它还引入主观MOS（Mean Opinion Score）评分作为最终盲测环节的补充。挑战提供ESPnet工具包的基线模型，鼓励数据增强，但严格限制训练数据来源，确保公平性。</p>
<p>通过这个挑战，我们可以看到评估不仅是“打分”，而是推动行业向真实场景迈进的基准。接下来，重点介绍挑战中使用的核心客观指标：PESQ、ESTOI、SDR、MCD、LSD、DNSMOS和NISQA。</p>
<h2 id="评估指标详解每个指标都在测什么">评估指标详解：每个指标都在测什么？</h2>
<p>语音增强评估指标大致分为侵入式（需要干净参考信号）和非侵入式（无需参考，模拟真实场景）。URGENT 2024挑战选用这些指标来全面考察算法的语音质量、可懂度和保真度。下面逐一解释：</p>
<ul>
<li>
<p><strong>PESQ (Perceptual Evaluation of Speech Quality)</strong>：这是一个侵入式指标，通过比较增强后的语音与参考干净信号，评估感知质量。它关注失真和噪声对人类听觉的影响，得分范围通常为-0.5到4.5（越高越好）。在语音增强中，PESQ常用于客观测试算法的整体质量，尤其适合电话或VoIP场景。</p>
</li>
<li>
<p><strong>ESTOI (Extended Short-Time Objective Intelligibility)</strong>：侵入式指标，专注于评估增强语音的可懂度。它分析短时段信号，预测听者在噪声下的理解能力，得分从0到1（越高表示更易懂）。这个指标特别适用于低信噪比环境，帮助算法优化对人类认知的友好度。</p>
</li>
<li>
<p><strong>SDR (Signal-to-Distortion Ratio)</strong>：侵入式指标，计算期望信号能量与失真（包括噪声和伪影）能量的比率，通常以dB为单位（越高越好）。它评估增强信号的整体保真度，在多通道或复杂噪声场景中非常实用。</p>
</li>
<li>
<p><strong>MCD (Mel-Cepstral Distortion)</strong>：侵入式指标，量化增强信号与参考信号在梅尔倒谱系数上的差异（越低越好）。它聚焦谱失真，提供对感知质量的洞察，常用于评估算法对语音频谱的保留能力。</p>
</li>
<li>
<p><strong>LSD (Log-Spectral Distance)</strong>：侵入式指标，测量增强和参考信号功率谱的对数差异（越低越好）。它评估谱准确性，帮助理解算法如何保留原始语音特征，适用于频域分析。</p>
</li>
<li>
<p><strong>DNSMOS (Deep Noise Suppression Mean Opinion Score)</strong>：非侵入式指标，无需参考信号，使用深度学习模型预测语音质量（模拟人类评分，范围1-5）。它基于人类评级训练，适用于真实场景评估，尤其当干净参考不可用时。</p>
</li>
<li>
<p><strong>NISQA (Non-Intrusive Speech Quality Assessment)</strong>：同样是非侵入式指标，使用机器学习预测感知质量，无需参考。它评估整体语音质量，在参考信号缺失的实际部署中大放异彩。</p>
</li>
</ul>
<p>这些指标组合使用，能从质量、可懂度和失真等多维度评估算法。URGENT挑战强调，非侵入式指标如DNSMOS和NISQA更贴近现实，因为真实环境中往往没有干净参考。</p>
<h2 id="评测数据集从哪里获取如何使用">评测数据集：从哪里获取，如何使用？</h2>
<p>要实际计算这些指标，需要可靠的数据集。URGENT 2024挑战通过其GitHub仓库提供官方评测数据集，托管在Hugging Face上，便于下载和使用。</p>
<ul>
<li><strong>官方评测数据集</strong>：包括验证集、非盲测集和盲测集，地址：https://huggingface.co/datasets/urgent-challenge/urgent2024_official。这些数据集包含各种失真条件下的语音样本，适合测试算法的通用性。</li>
<li><strong>MOS数据集</strong>：额外提供带人类标注MOS分数的语音质量评估数据集，地址：https://huggingface.co/datasets/urgent-challenge/urgent2024_mos。用于主观指标验证。</li>
</ul>
<p>访问方式简单：在Hugging Face平台搜索并下载，或使用Python的datasets库加载。数据集设计覆盖不同噪声、混响和麦克风配置，确保评估的全面性。</p>
<blockquote>
<p>可以参考下面的代码将hugging face中的validataion数据集以wav形式保存在本地，方便后续不同算法进行处理后，对处理结果进行评估。</p></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">datasets</span> <span class="kn">import</span> <span class="n">load_dataset</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">soundfile</span> <span class="k">as</span> <span class="nn">sf</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 参数 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">DATASET_NAME</span> <span class="o">=</span> <span class="s2">&#34;urgent-challenge/urgent2024_official&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">SPLIT</span> <span class="o">=</span> <span class="s2">&#34;validation&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">SAVE_DIR</span> <span class="o">=</span> <span class="s2">&#34;../data/validation&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">NUM_PROC</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># 并行进程数，可以改成你的 CPU 核心数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 目录准备 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">clean_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">,</span> <span class="s2">&#34;clean&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">noisy_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">,</span> <span class="s2">&#34;noisy&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">clean_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">noisy_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 加载数据 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="n">DATASET_NAME</span><span class="p">,</span> <span class="n">SPLIT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 保存函数 =====</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">save_audio</span><span class="p">(</span><span class="n">example</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">uid</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="s2">&#34;id&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># noisy</span>
</span></span><span class="line"><span class="cl">    <span class="n">noisy</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="s2">&#34;noisy_audio&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">noisy_samples</span><span class="p">,</span> <span class="n">noisy_sr</span> <span class="o">=</span> <span class="n">noisy</span><span class="p">[</span><span class="s2">&#34;array&#34;</span><span class="p">],</span> <span class="n">noisy</span><span class="p">[</span><span class="s2">&#34;sampling_rate&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># clean</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="s2">&#34;clean_audio&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean_samples</span><span class="p">,</span> <span class="n">clean_sr</span> <span class="o">=</span> <span class="n">clean</span><span class="p">[</span><span class="s2">&#34;array&#34;</span><span class="p">],</span> <span class="n">clean</span><span class="p">[</span><span class="s2">&#34;sampling_rate&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 确保采样率一致</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">noisy_sr</span> <span class="o">==</span> <span class="n">clean_sr</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&#34;Sample rate mismatch: noisy=</span><span class="si">{</span><span class="n">noisy_sr</span><span class="si">}</span><span class="s2">, clean=</span><span class="si">{</span><span class="n">clean_sr</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 保存文件路径</span>
</span></span><span class="line"><span class="cl">    <span class="n">noisy_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">noisy_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s2">.wav&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clean_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s2">.wav&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 写文件</span>
</span></span><span class="line"><span class="cl">    <span class="n">sf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">noisy_path</span><span class="p">,</span> <span class="n">noisy_samples</span><span class="p">,</span> <span class="n">noisy_sr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">clean_path</span><span class="p">,</span> <span class="n">clean_samples</span><span class="p">,</span> <span class="n">clean_sr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="s2">&#34;noisy_path&#34;</span><span class="p">:</span> <span class="n">noisy_path</span><span class="p">,</span> <span class="s2">&#34;clean_path&#34;</span><span class="p">:</span> <span class="n">clean_path</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 多进程导出 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">save_audio</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">num_proc</span><span class="o">=</span><span class="n">NUM_PROC</span><span class="p">,</span>      <span class="c1"># 开启多进程</span>
</span></span><span class="line"><span class="cl">    <span class="n">desc</span><span class="o">=</span><span class="s2">&#34;Exporting audio&#34;</span><span class="p">,</span> <span class="c1"># tqdm 进度条描述</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="指标计算实践一步步上手">指标计算实践：一步步上手</h2>
<p>计算这些指标需要工具和脚本。URGENT挑战的GitHub仓库（https://github.com/urgent-challenge/urgent2024_challenge）提供了evaluation_metrics文件夹下的实用脚本，如calculate_intrusive_se_metrics.py（处理PESQ、ESTOI、SDR、MCD、LSD等侵入式指标，支持无限SDR值处理），calculate_nonintrusive_dnsmos.py和calculate_nonintrusive_nisqa.py分别计算DNSMOS和NISQA。</p>
<p><strong>计算步骤示例</strong>：</p>
<blockquote>
<p>参考evaluation_metrics/README.md</p></blockquote>
<ol>
<li><strong>数据准备</strong>对validation数据集中的noisy数据进行处理，得到enhanced的数据，按下面的目录结构进行组织
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">📁 /path/to/your/data/
</span></span><span class="line"><span class="cl">├── 📁 enhanced/
</span></span><span class="line"><span class="cl">│   ├── 🔈 fileid_1.wav
</span></span><span class="line"><span class="cl">│   ├── 🔈 fileid_2.wav
</span></span><span class="line"><span class="cl">│   └── ...
</span></span><span class="line"><span class="cl">└── 📁 clean/
</span></span><span class="line"><span class="cl">    ├── 🔈 fileid_1.wav
</span></span><span class="line"><span class="cl">    ├── 🔈 fileid_2.wav
</span></span><span class="line"><span class="cl">    └── ...
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>生成scp文件</strong> 为clean数据和enhance数据生成对应的scp文件，在scp文件中包含两列信息，一列是一个唯一的文件id，一列是文件路径，如下
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># enhanced.scp
</span></span><span class="line"><span class="cl">fileid_1 /path/to/your/data/enhanced/fileid_1.flac
</span></span><span class="line"><span class="cl">fileid_2 /path/to/your/data/enhanced/fileid_2.flac
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># reference.scp
</span></span><span class="line"><span class="cl">fileid_1 /path/to/your/data/clean/fileid_1.flac
</span></span><span class="line"><span class="cl">fileid_2 /path/to/your/data/clean/fileid_2.flac
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>运行脚本</strong>：例如，对于侵入式指标，运行<code>calculate_intrusive_se_metrics.py</code>输入增强文件和参考文件，输出PESQ等分数。非侵入式如DNSMOS可直接输入增强语音。</li>
<li><strong>示例代码片段</strong>：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nv">nj</span><span class="o">=</span><span class="m">8</span>  <span class="c1"># Number of parallel CPU jobs for speedup</span>
</span></span><span class="line"><span class="cl"><span class="nv">python</span><span class="o">=</span>python3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">output_prefix</span><span class="o">=</span>metrics_score
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># PESQ, ESTOI, SDR, MCD, LSD</span>
</span></span><span class="line"><span class="cl"><span class="si">${</span><span class="nv">python</span><span class="si">}</span> calculate_intrusive_se_metrics.py <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --ref_scp reference.scp <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --inf_scp enhanced_webrtc.scp <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --output_dir <span class="s2">&#34;</span><span class="si">${</span><span class="nv">output_prefix</span><span class="si">}</span><span class="s2">&#34;</span>/scoring_webrtc <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --nj <span class="si">${</span><span class="nv">nj</span><span class="si">}</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --chunksize <span class="m">60</span>
</span></span></code></pre></td></tr></table>
</div>
</div>对于批量计算，仓库脚本支持文件夹输入。</li>
</ol>
<p>在实践中，建议结合主观听测（如MOS）验证客观指标，避免“高分低体验”的情况。</p>
<h2 id="结语评估驱动创新">结语：评估驱动创新</h2>
<p>语音增强算法评估不是终点，而是起点。通过URGENT 2024这样的挑战，我们看到评估体系在推动算法向通用、鲁棒方向演进。未来，随着更多非侵入式指标和多模态数据的融入，评估将更贴近真实世界。</p>
<p>最后我们来看下之前介绍的WebRTC NS是什么水平吧，最终的指标如下所示。</p>
<p><img alt="webrtc ns算法评估指标" loading="lazy" src="/images/2025-08-11/validation_webrtc_ns.png"></p>
<p><img alt="noisy" loading="lazy" src="/images/2025-08-11/validation_noisy.png"></p>
<p>可以看到WebRTC NS的评估指标分数只比noisy的分数好一点点，可见还有很大的上升空间。传统算法或多或少都会基于一些假设，而这些假设不只小范围内是生效的，这造成了传统算法的局限性。近年深度学习基于数据驱动的方法，进一步突破这些局限性，极大提高了音频算法的效果上线。下期预告，让我们迈上深度学习时代吧。</p>
<img src="/images/To-Be-Continued.jpeg"/>]]></content:encoded>
    </item>
  </channel>
</rss>
